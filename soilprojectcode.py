# -*- coding: utf-8 -*-
"""SoilProjectCode.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nDwLKO0WLZyE5_sqWVxwV6ulMDXcQmLg

# Decision Tree Classification

## Importing the libraries
"""

import numpy as np
import matplotlib.pyplot as plt
import  pandas as pd

"""## Importing the dataset"""

dataset = pd.read_csv("/content/soildataset.csv")

"""## Data analysis"""

dataset.shape

dataset.head()

dataset.info()

"""## Preparing Data into Input Feature and Output Target Class"""

from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import LabelEncoder
Nitrogen=pd.DataFrame()
Nitrogen['Value']=dataset['Nitrogen']
Nitrogen['Label_Nitrogen']=LabelEncoder().fit_transform(dataset['Content of Nitrogen'])

Phosphorous=pd.DataFrame()
Phosphorous['Value']=dataset['Phosphorous']
Phosphorous['Label_Phosphorous']=LabelEncoder().fit_transform(dataset['Content of Phosphorous'])

Potassium=pd.DataFrame()
Potassium['Value']=dataset['Potassium']
Potassium['Label_Potassium']=LabelEncoder().fit_transform(dataset['Content of Potassium'])

X = dataset.iloc[:,:-3].values
y = Nitrogen.iloc[:,-1].values

"""## Splitting the dataset into the Training set and Test set"""

from sklearn.model_selection import train_test_split
X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.20,random_state=0)

from sklearn.naive_bayes import MultinomialNB  #classifier is suitable for classification with discrete features
model = MultinomialNB()
model.fit(X_train, y_train)

y_naive = model.predict(X_test)
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
ac = accuracy_score(y_test, y_naive)
cm = confusion_matrix(y_test, y_naive)
print('Accuracy for Naive Bayes is: ',ac)

from sklearn.ensemble import RandomForestClassifier
# Instantiate model with 1000 decision trees
rf = RandomForestClassifier(random_state=1)
# Train the model on training data
rf.fit(X_train, y_train)

predictions = rf.predict(X_test)

rf.score(X_test,predictions)

"""## Feature Scaling"""

from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X_train_std = sc.fit_transform(X_train)
X_test_std =sc.fit_transform(X_test)

"""## Training the Decision Tree Classification model on the Training set"""

from sklearn.tree import DecisionTreeClassifier
y_train_std=y_train
classifier = DecisionTreeClassifier(criterion = 'entropy',random_state= 0)
classifier.fit(X_train_std,y_train_std)

"""## Predicting the Test set results"""

y_pred = classifier.predict(X_test_std)

"""## Making the Confusion Matrix"""

from sklearn.metrics import confusion_matrix,accuracy_score
from sklearn.multioutput import MultiOutputClassifier

cm = confusion_matrix(y_test, y_pred)

print("Accuracy for Decision Tree:",accuracy_score(y_test, y_pred))

"""## Visualising the Training set results

## VISUALIZE TEXT REPRESENTATION
"""

from sklearn import tree
text_representation = tree.export_text(classifier)
print(text_representation)

fig = plt.figure(figsize=(25,20))
tree.plot_tree(classifier)

"""# Using SVM"""

from sklearn.svm import SVC

svm = SVC(kernel='rbf')
svm.fit(X_train_std, y_train)
svm_pred=svm.predict(X_test_std)

print('Accuracy: training data is {:.2f} out of 1'.format(svm.score(X_train_std, y_train)))

print('Accuracy: test data is {:.2f} out of 1'.format(svm.score(X_test_std, y_test)))

"""# Classification Report"""

from sklearn.metrics import classification_report
print("Decision Tree:")
print(classification_report(y_test,y_pred))
print("Naive Bayes:")
print(classification_report(y_test,y_naive))
print("Random Forest:")
print(classification_report(y_test, predictions))
print("Support Vector Machine:")
print(classification_report(y_test, svm_pred))

from sklearn.metrics import jaccard_score, f1_score
print(jaccard_score(y_true=y_test,y_pred=y_pred,average='weighted'))

f1_score(y_test,y_pred, average='weighted')

from sklearn.metrics import jaccard_score, f1_score
print(jaccard_score(y_true=y_test,y_pred=y_naive,average='weighted'))

f1_score(y_test,y_naive, average='weighted')

"""# Dataset Generation using Random Function"""

df = pd.DataFrame(np.random.uniform(1, 5, size=(100, 3)), columns=list('NPK'))
df.insert[3,'Content of Nitrogen',[for i in df[N] if i<2.5: 'Low' elif i>2.5 and i<3.5 'Medium' else 'High']]
df
df.to_csv('test.csv', index=False)